package wiimote;

public interface State extends org.ros.internal.message.Message {
  static final java.lang.String _TYPE = "wiimote/State";
  static final java.lang.String _DEFINITION = "#\n#          Wiimote State message containing one complete Wiimote state\n\n# Note: For ease of manipulation this message often uses\n#       int8[] when a bit vector would work. One might\n#       wish to use uint8[], but then Python takes\n#       the respective structure as a string and disallows\n#       item assignment.\n\nint8    INVALID       = -1\nfloat32 INVALID_FLOAT = -1.0\n\nint8 MSG_BTN_1     = 0\nint8 MSG_BTN_2     = 1\nint8 MSG_BTN_A     = 2\nint8 MSG_BTN_B     = 3\nint8 MSG_BTN_PLUS  = 4\nint8 MSG_BTN_MINUS = 5\nint8 MSG_BTN_LEFT  = 6\nint8 MSG_BTN_RIGHT = 7\nint8 MSG_BTN_UP    = 8\nint8 MSG_BTN_DOWN  = 9\nint8 MSG_BTN_HOME  = 10\nint8 MSG_BTN_Z     = 0\nint8 MSG_BTN_C     = 1\nint8 MSG_CLASSIC_BTN_X       = 0\nint8 MSG_CLASSIC_BTN_Y       = 1\nint8 MSG_CLASSIC_BTN_A       = 2\nint8 MSG_CLASSIC_BTN_B       = 3\nint8 MSG_CLASSIC_BTN_PLUS    = 4\nint8 MSG_CLASSIC_BTN_MINUS   = 5\nint8 MSG_CLASSIC_BTN_LEFT    = 6\nint8 MSG_CLASSIC_BTN_RIGHT   = 7\nint8 MSG_CLASSIC_BTN_UP      = 8\nint8 MSG_CLASSIC_BTN_DOWN    = 9\nint8 MSG_CLASSIC_BTN_HOME    = 10\nint8 MSG_CLASSIC_BTN_L       = 11\nint8 MSG_CLASSIC_BTN_R       = 12\nint8 MSG_CLASSIC_BTN_ZL      = 13\nint8 MSG_CLASSIC_BTN_ZR      = 14\n\n#-----------------------------\n# Header\n#----------------------\n\nHeader header\n\n#----------------------\n# Gyro reading\n#-----------------------------\n# In radians/sec. If reading is invalid,\n# for instance b/c no gyro is attached to the Wii, then\n# set first element of covariance to -1 (same as imu_data.msg):\n# Covariance matrix (roll, pitch, yaw) in radians^2/sec^2.\n\ngeometry_msgs/Vector3 angular_velocity_zeroed\ngeometry_msgs/Vector3 angular_velocity_raw\nfloat64[9] angular_velocity_covariance\n\n#----------------------\n# Accelerometer reading\n#-----------------------------\n# Acceleration in m/sec^2. Covariance matrix\n# (x,y,z) in m^2/sec^4.  (all same as imu_data.msg)\n\ngeometry_msgs/Vector3 linear_acceleration_zeroed\ngeometry_msgs/Vector3 linear_acceleration_raw\nfloat64[9] linear_acceleration_covariance\n\n#------------------------------\n# Nunchuk Accelerometer reading\n#------------------------------\ngeometry_msgs/Vector3 nunchuk_acceleration_zeroed\ngeometry_msgs/Vector3 nunchuk_acceleration_raw\n\n#-----------------\n# Nunchuk Joystick\n#-----------------\nfloat32[2] nunchuk_joystick_zeroed\nfloat32[2] nunchuk_joystick_raw\n\n#----------------------\n# Wiimote buttons\n#-----------------------------\n# Mappings from Wiimote button name\n# to array position are defined above.\n#\nbool[11] buttons\nbool[2] nunchuk_buttons\n\n#----------------------\n# Wiimote LED states:\n#-----------------------------\n\nbool[4] LEDs\n\n#----------------------\n# Wiimote Rumble\n#-----------------------------\n# State (True or False)\n\nbool rumble\n\n#----------------------\n# IR Light sensor (Camera)\n#-----------------------------\n# The Wiimote handles up to four light sources, \n# and the wiimote_node.py software is written to \n# that limit as well. For future expansion\n# we make the following array extensible, rather\n# than locking its length down to four:\n\nwiimote/IrSourceInfo[] ir_tracking\n\n#----------------------\n# Wiimote battery\n#-----------------------------\n# A battery reading consists of two numbers: \n# the battery percentage, and the raw reading.\n# Maximum battery is 208 units (unknown how this\n# relates to electrical properties): \n\nfloat32 raw_battery\nfloat32 percent_battery\n\n#----------------------\n# Time of most recent zeroing:\n#-----------------------------\n\ntime zeroing_time\n\n#----------------------\n# Error vector\n#-----------------------------\n# For error condition definitions see wiimoteConstants.py\n# Value of zero means all is well. (Currently NOT used).\n\nuint64 errors\n";
  static final byte INVALID = -1;
  static final float INVALID_FLOAT = -1.0f;
  static final byte MSG_BTN_1 = 0;
  static final byte MSG_BTN_2 = 1;
  static final byte MSG_BTN_A = 2;
  static final byte MSG_BTN_B = 3;
  static final byte MSG_BTN_PLUS = 4;
  static final byte MSG_BTN_MINUS = 5;
  static final byte MSG_BTN_LEFT = 6;
  static final byte MSG_BTN_RIGHT = 7;
  static final byte MSG_BTN_UP = 8;
  static final byte MSG_BTN_DOWN = 9;
  static final byte MSG_BTN_HOME = 10;
  static final byte MSG_BTN_Z = 0;
  static final byte MSG_BTN_C = 1;
  static final byte MSG_CLASSIC_BTN_X = 0;
  static final byte MSG_CLASSIC_BTN_Y = 1;
  static final byte MSG_CLASSIC_BTN_A = 2;
  static final byte MSG_CLASSIC_BTN_B = 3;
  static final byte MSG_CLASSIC_BTN_PLUS = 4;
  static final byte MSG_CLASSIC_BTN_MINUS = 5;
  static final byte MSG_CLASSIC_BTN_LEFT = 6;
  static final byte MSG_CLASSIC_BTN_RIGHT = 7;
  static final byte MSG_CLASSIC_BTN_UP = 8;
  static final byte MSG_CLASSIC_BTN_DOWN = 9;
  static final byte MSG_CLASSIC_BTN_HOME = 10;
  static final byte MSG_CLASSIC_BTN_L = 11;
  static final byte MSG_CLASSIC_BTN_R = 12;
  static final byte MSG_CLASSIC_BTN_ZL = 13;
  static final byte MSG_CLASSIC_BTN_ZR = 14;
  std_msgs.Header getHeader();
  void setHeader(std_msgs.Header value);
  geometry_msgs.Vector3 getAngularVelocityZeroed();
  void setAngularVelocityZeroed(geometry_msgs.Vector3 value);
  geometry_msgs.Vector3 getAngularVelocityRaw();
  void setAngularVelocityRaw(geometry_msgs.Vector3 value);
  double[] getAngularVelocityCovariance();
  void setAngularVelocityCovariance(double[] value);
  geometry_msgs.Vector3 getLinearAccelerationZeroed();
  void setLinearAccelerationZeroed(geometry_msgs.Vector3 value);
  geometry_msgs.Vector3 getLinearAccelerationRaw();
  void setLinearAccelerationRaw(geometry_msgs.Vector3 value);
  double[] getLinearAccelerationCovariance();
  void setLinearAccelerationCovariance(double[] value);
  geometry_msgs.Vector3 getNunchukAccelerationZeroed();
  void setNunchukAccelerationZeroed(geometry_msgs.Vector3 value);
  geometry_msgs.Vector3 getNunchukAccelerationRaw();
  void setNunchukAccelerationRaw(geometry_msgs.Vector3 value);
  float[] getNunchukJoystickZeroed();
  void setNunchukJoystickZeroed(float[] value);
  float[] getNunchukJoystickRaw();
  void setNunchukJoystickRaw(float[] value);
  boolean[] getButtons();
  void setButtons(boolean[] value);
  boolean[] getNunchukButtons();
  void setNunchukButtons(boolean[] value);
  boolean[] getLEDs();
  void setLEDs(boolean[] value);
  boolean getRumble();
  void setRumble(boolean value);
  java.util.List<wiimote.IrSourceInfo> getIrTracking();
  void setIrTracking(java.util.List<wiimote.IrSourceInfo> value);
  float getRawBattery();
  void setRawBattery(float value);
  float getPercentBattery();
  void setPercentBattery(float value);
  org.ros.message.Time getZeroingTime();
  void setZeroingTime(org.ros.message.Time value);
  long getErrors();
  void setErrors(long value);
}
